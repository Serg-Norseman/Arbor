//
//  Arbor - version 0.91
//  a graph vizualization toolkit
//
//  Copyright (c) 2011 Samizdat Drafting Co.
//  Physics code derived from springy.js, copyright (c) 2010 Dennis Hotson
// 
(function ($) {

"use strict";

    var ext = {
        loadurl:function (dest) {
            var xhReq;
            if (window.XMLHttpRequest) { // Non-IE browsers
                xhReq = new XMLHttpRequest();
            } else if (window.ActiveXObject) { // IE
                xhReq = new ActiveXObject("Microsoft.XMLHTTP");
            }
            xhReq.open("GET", dest, false);
            xhReq.send(null);
            var serverResponse = xhReq.responseText;
            return serverResponse;
        },
        attr:function (key, value, type) {
            var obj = key;

            // Look for the case where we're accessing a style value
            if (key.constructor === String)
                if (value === undefined)
                    return this.length && jQuery[ type || "attr" ](this[0], key) || undefined;
                else {
                    obj = {};
                    obj[ key ] = value;
                }

            // Check to see if we're setting style values
            return this.each(function (index) {
                // Set all the styles
                for (var prop in obj)
                    jQuery.attr(
                        type ? this.style : this,
                        prop, jQuery.prop(this, obj[prop], type, index, prop)
                    );
            });
        },
        each:function (d, e) {
            if (ext.isArray(d)) {
                for (var c = 0, b = d.length; c < b; c++) {
                    e(c, d[c]);
                }
            } else {
                for (var a in d) {
                    e(a, d[a]);
                }
            }
        },
        map:function (a, c) {
            var b = [];
            ext.each(a, function (f, e) {
                var d = c(e);
                if (d !== undefined) {
                    b.push(d);
                }
            });
            return b;
        },
        extend:function (c, b) {
            if (typeof b !== "object") {
                return c;
            }
            for (var a in b) {
                if (b.hasOwnProperty(a)) {
                    c[a] = b[a];
                }
            }
            return c;
        },
        isArray:function (a) {
            if (!a) {
                return false;
            }
            return (a.constructor.toString().indexOf("Array") !== -1);
        },
        inArray:function (c, a) {
            for (var d = 0, b = a.length; d < b; d++) {
                if (a[d] === c) {
                    return d;
                }
            }
            return -1;
        },
        isEmptyObject:function (a) {
            if (typeof a !== "object") {
                return false;
            }
            var b = true;
            ext.each(a, function () {
                b = false;
            });
            return b;
        }
    };

    var trace = function (msg) {
        console.log(msg);
    };

    var nano = function (a, b) {
        return a.replace(/\{([\w\-\.]*)}/g, function (f, c) {
            var d = c.split("."),
                e = b[d.shift()];
            ext.each(d, function () {
                if (e.hasOwnProperty(this)) {
                    e = e[this];
                } else {
                    e = f;
                }
            });
            return e;
        });
    };

    var objcopy = function (a) {
        if (a === undefined) {
            return undefined;
        }
        if (a === null) {
            return null;
        }
        if (a.parentNode) {
            return a;
        }
        switch (typeof a) {
            case "string":
                return a.substring(0);
            case "number":
                return a + 0;
            case "boolean":
                return a === true;
        }
        var b = (ext.isArray(a)) ? [] : {};
        ext.each(a, function (d, c) {
            b[d] = objcopy(c);
        });
        return b;
    };

    var objmerge = function (d, b) {
        d = d || {};
        b = b || {};
        var c = objcopy(d);
        for (var a in b) {
            c[a] = b[a];
        }
        return c;
    };

    var objkeys = function (b) {
        var a = [];
        ext.each(b, function (d) {
            if (b.hasOwnProperty(d)) {
                a.push(d);
            }
        });
        return a;
    };


    var Colors = (function () {
        var f = /#[0-9a-f]{6}/i;
        var b = /#(..)(..)(..)/;
        var c = function (h) {
            var g = h.toString(16);
            return (g.length === 2) ? g : "0" + g;
        };
        var a = function (g) {
            return parseInt(g, 16);
        };
        var d = function (g) {
            if (!g || typeof g !== "object") {
                return false;
            }
            var h = objkeys(g).sort().join("");
            if (h === "abgr") {
                return true;
            }
        };
        var e = {
            CSS:{
                aliceblue:"#f0f8ff",
                antiquewhite:"#faebd7",
                aqua:"#00ffff",
                aquamarine:"#7fffd4",
                azure:"#f0ffff",
                beige:"#f5f5dc",
                bisque:"#ffe4c4",
                black:"#000000",
                blanchedalmond:"#ffebcd",
                blue:"#0000ff",
                blueviolet:"#8a2be2",
                brown:"#a52a2a",
                burlywood:"#deb887",
                cadetblue:"#5f9ea0",
                chartreuse:"#7fff00",
                chocolate:"#d2691e",
                coral:"#ff7f50",
                cornflowerblue:"#6495ed",
                cornsilk:"#fff8dc",
                crimson:"#dc143c",
                cyan:"#00ffff",
                darkblue:"#00008b",
                darkcyan:"#008b8b",
                darkgoldenrod:"#b8860b",
                darkgray:"#a9a9a9",
                darkgrey:"#a9a9a9",
                darkgreen:"#006400",
                darkkhaki:"#bdb76b",
                darkmagenta:"#8b008b",
                darkolivegreen:"#556b2f",
                darkorange:"#ff8c00",
                darkorchid:"#9932cc",
                darkred:"#8b0000",
                darksalmon:"#e9967a",
                darkseagreen:"#8fbc8f",
                darkslateblue:"#483d8b",
                darkslategray:"#2f4f4f",
                darkslategrey:"#2f4f4f",
                darkturquoise:"#00ced1",
                darkviolet:"#9400d3",
                deeppink:"#ff1493",
                deepskyblue:"#00bfff",
                dimgray:"#696969",
                dimgrey:"#696969",
                dodgerblue:"#1e90ff",
                firebrick:"#b22222",
                floralwhite:"#fffaf0",
                forestgreen:"#228b22",
                fuchsia:"#ff00ff",
                gainsboro:"#dcdcdc",
                ghostwhite:"#f8f8ff",
                gold:"#ffd700",
                goldenrod:"#daa520",
                gray:"#808080",
                grey:"#808080",
                green:"#008000",
                greenyellow:"#adff2f",
                honeydew:"#f0fff0",
                hotpink:"#ff69b4",
                indianred:"#cd5c5c",
                indigo:"#4b0082",
                ivory:"#fffff0",
                khaki:"#f0e68c",
                lavender:"#e6e6fa",
                lavenderblush:"#fff0f5",
                lawngreen:"#7cfc00",
                lemonchiffon:"#fffacd",
                lightblue:"#add8e6",
                lightcoral:"#f08080",
                lightcyan:"#e0ffff",
                lightgoldenrodyellow:"#fafad2",
                lightgray:"#d3d3d3",
                lightgrey:"#d3d3d3",
                lightgreen:"#90ee90",
                lightpink:"#ffb6c1",
                lightsalmon:"#ffa07a",
                lightseagreen:"#20b2aa",
                lightskyblue:"#87cefa",
                lightslategray:"#778899",
                lightslategrey:"#778899",
                lightsteelblue:"#b0c4de",
                lightyellow:"#ffffe0",
                lime:"#00ff00",
                limegreen:"#32cd32",
                linen:"#faf0e6",
                magenta:"#ff00ff",
                maroon:"#800000",
                mediumaquamarine:"#66cdaa",
                mediumblue:"#0000cd",
                mediumorchid:"#ba55d3",
                mediumpurple:"#9370d8",
                mediumseagreen:"#3cb371",
                mediumslateblue:"#7b68ee",
                mediumspringgreen:"#00fa9a",
                mediumturquoise:"#48d1cc",
                mediumvioletred:"#c71585",
                midnightblue:"#191970",
                mintcream:"#f5fffa",
                mistyrose:"#ffe4e1",
                moccasin:"#ffe4b5",
                navajowhite:"#ffdead",
                navy:"#000080",
                oldlace:"#fdf5e6",
                olive:"#808000",
                olivedrab:"#6b8e23",
                orange:"#ffa500",
                orangered:"#ff4500",
                orchid:"#da70d6",
                palegoldenrod:"#eee8aa",
                palegreen:"#98fb98",
                paleturquoise:"#afeeee",
                palevioletred:"#d87093",
                papayawhip:"#ffefd5",
                peachpuff:"#ffdab9",
                peru:"#cd853f",
                pink:"#ffc0cb",
                plum:"#dda0dd",
                powderblue:"#b0e0e6",
                purple:"#800080",
                red:"#ff0000",
                rosybrown:"#bc8f8f",
                royalblue:"#4169e1",
                saddlebrown:"#8b4513",
                salmon:"#fa8072",
                sandybrown:"#f4a460",
                seagreen:"#2e8b57",
                seashell:"#fff5ee",
                sienna:"#a0522d",
                silver:"#c0c0c0",
                skyblue:"#87ceeb",
                slateblue:"#6a5acd",
                slategray:"#708090",
                slategrey:"#708090",
                snow:"#fffafa",
                springgreen:"#00ff7f",
                steelblue:"#4682b4",
                tan:"#d2b48c",
                teal:"#008080",
                thistle:"#d8bfd8",
                tomato:"#ff6347",
                turquoise:"#40e0d0",
                violet:"#ee82ee",
                wheat:"#f5deb3",
                white:"#ffffff",
                whitesmoke:"#f5f5f5",
                yellow:"#ffff00",
                yellowgreen:"#9acd32"
            },
            decode:function (h) {
                var g = arguments.length;
                for (var l = g - 1; l >= 0; l--) {
                    if (arguments[l] === undefined) {
                        g--;
                    }
                }
                var k = arguments;
                if (!h) {
                    return null;
                }
                if (g === 1 && d(h)) {
                    return h;
                }
                var j = null;
                if (typeof h === "string") {
                    var o = 1;
                    if (g === 2) {
                        o = k[1];
                    }
                    var n = e.CSS[h.toLowerCase()];
                    if (n !== undefined) {
                        h = n;
                    }
                    var m = h.match(f);
                    if (m) {
                        var vals = h.match(b);
                        if (!vals || !vals.length || vals.length !== 4) {
                            return null;
                        }
                        j = {
                            r:a(vals[1]),
                            g:a(vals[2]),
                            b:a(vals[3]),
                            a:o
                        };
                    }
                } else {
                    if (typeof h === "number") {
                        if (g >= 3) {
                            j = {
                                r:k[0],
                                g:k[1],
                                b:k[2],
                                a:1
                            };
                            if (g >= 4) {
                                j.a *= k[3];
                            }
                        } else {
                            if (g >= 1) {
                                j = {
                                    r:k[0],
                                    g:k[0],
                                    b:k[0],
                                    a:1
                                };
                                if (g === 2) {
                                    j.a *= k[1];
                                }
                            }
                        }
                    }
                }
                return j;
            },
            encode:function (g) {
                if (!d(g)) {
                    g = e.decode(g);
                    if (!d(g)) {
                        return "#cccccc"; // null replacement
                    }
                }

                var ret = nano("#{r}{g}{b}", {
                    r:c(g.r),
                    g:c(g.g),
                    b:c(g.b)
                });
                return ret;
            }
        };
        return e;
    })();


    var Primitives = function (c, f, g) {
        //_Oval: b
        var b = function (i, m, j, l, k) {
            this.x = i;
            this.y = m;
            this.w = j;
            this.h = l;
            this.style = (k !== undefined) ? k : {};
        };
        b.prototype = {
            _draw:function (i, n, j, l, k) {
                if (this.x !== undefined) {
                    i = this.x;
                    n = this.y;
                    j = this.w;
                    l = this.h;
                    k = objmerge(this.style, k);
                }
                k = objmerge(f, k);
                if (!k.stroke && !k.fill) {
                    return;
                }
                var m = 0.5522848;

                var ox = (j / 2) * m;
                var oy = (l / 2) * m;
                var xe = i + j;
                var ye = n + l;
                var xm = i + j / 2;
                var ym = n + l / 2;

                c.save();
                c.beginPath();
                c.moveTo(i, ym);
                c.bezierCurveTo(i, ym - oy, xm - ox, n, xm, n);
                c.bezierCurveTo(xm + ox, n, xe, ym - oy, xe, ym);
                c.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                c.bezierCurveTo(xm - ox, ye, i, ym + oy, i, ym);
                c.closePath();
                if (k.fill !== null) {
                    c.fillStyle = Colors.encode(k.fill);
                    c.fill();
                }
                if (k.stroke !== null) {
                    c.strokeStyle = Colors.encode(k.stroke);
                    if (!isNaN(k.width)) {
                        c.lineWidth = k.width;
                    }
                    c.stroke();
                }
                c.restore();
            }
        };
        //_Rect: a
        var a = function (i, n, j, l, m, k) {
            this.x = i;
            this.y = n;
            this.w = j;
            this.h = l;
            this.r = (m !== undefined) ? m : 0;
            this.style = (k !== undefined) ? k : {};
        };
        a.prototype = {
            _draw:function (j, o, k, m, n, l) {
                if (this.x !== undefined) {
                    j = this.x;
                    o = this.y;
                    k = this.w;
                    m = this.h;
                    l = objmerge(this.style, l);
                }
                l = objmerge(f, l);
                if (!l.stroke && !l.fill) {
                    return;
                }
                var i = (n > 0);
                c.save();
                c.beginPath();
                c.moveTo(j + n, o);
                c.lineTo(j + k - n, o);
                if (i) {
                    c.quadraticCurveTo(j + k, o, j + k, o + n);
                }
                c.lineTo(j + k, o + m - n);
                if (i) {
                    c.quadraticCurveTo(j + k, o + m, j + k - n, o + m);
                }
                c.lineTo(j + n, o + m);
                if (i) {
                    c.quadraticCurveTo(j, o + m, j, o + m - n);
                }
                c.lineTo(j, o + n);
                if (i) {
                    c.quadraticCurveTo(j, o, j + n, o);
                }
                if (l.fill !== null) {
                    c.fillStyle = Colors.encode(l.fill);
                    c.fill();
                }
                if (l.stroke !== null) {
                    c.strokeStyle = Colors.encode(l.stroke);
                    trace("rect.strokeStyle: " + c.strokeStyle);
                    if (!isNaN(l.width)) {
                        c.lineWidth = l.width;
                    }
                    c.stroke();
                }
                c.restore();
            }
        };
        return {
            _Oval:b,
            _Rect:a
        };
    };


    var Graphics = function (c) {
        var q = c.getContext("2d");

        var p = {
            background:null,
            fill:null,
            stroke:null,
            width:0
        };
        var g = {
            font:"sans-serif",
            size:12,
            align:"left",
            color:Colors.decode("black"),
            alpha:1,
            baseline:"ideographic"
        };

        var o = Primitives(q, p, g);
        var j = {
            init:function () {
                if (!q) {
                    return null;
                }
                return j;
            },

            clear:function (r, u, s, t) {
                if (arguments.length < 4) {
                    r = 0;
                    u = 0;
					var h = $(c);
                    s = h.attr("width");
                    t = h.attr("height");
                }
                q.clearRect(r, u, s, t);
                if (p.background !== null) {
                    q.save();
                    q.fillStyle = Colors.encode(p.background);
                    q.fillRect(r, u, s, t);
                    q.restore();
                }
            },

            rect:function (s, A, t, v, z, u) {
                o._Rect.prototype._draw(s, A, t, v, z, u);
            },

            oval:function (r, v, s, u, t) {
                t = t || {};
                o._Oval.prototype._draw(r, v, s, u, t);
            }
		};
        return j.init();
    };


    var Kernel = function (b) {
        var i = null;
        var c = null;
        var f = [];
        f.last = new Date();
        var e = null;
        var d = null;
        var h = null;
        var g = false;
        var j = {
            system:b,
            nodes:{},
            init:function () {
                var m = b.parameters();
                i = Physics(m.dt, m.stiffness, m.repulsion, m.friction, j.system._updateGeometry);
                j.start();
                return j;
            },
            graphChanged:function (m) {
                i._update(m);
                j.start();
            },
            particleModified:function (n, m) {
                i.modifyNode(n, m);
                j.start();
            },
            physicsModified:function (m) {
                if (!isNaN(m.timeout)) {
                    clearInterval(d);
                    d = null;
                }
                i.modifyPhysics(m);
                j.start();
            },
            _lastPositions:null,
            _lastFrametime:new Date().valueOf(),
            _lastBounds:null,
            _currentRenderer:null,
            screenUpdate:function () {
                var m = false;
                if (j._lastPositions !== null) {
                    j.system._updateGeometry(j._lastPositions);
                    j._lastPositions = null;
                    m = true;
                }
                if (c && c.busy()) {
                    m = true;
                }
                if (j.system._updateBounds(j._lastBounds)) {
                    m = true;
                }
                if (m) {
                    var o = j.system.renderer;
                    if (o !== undefined) {
                        if (o !== e) {
                            o.init(j.system);
                            e = o;
                        }
                        if (c) {
                            c.tick();
                        }
                        o.redraw();
                        var p = f.last;
                        f.last = new Date();
                        f.push(f.last - p);
                        if (f.length > 50) {
                            f.shift();
                        }
                    }
                }
            },
            physicsUpdate:function () {
                if (c) {
                    c.tick();
                }
                i.tick();
                var n = j.system._updateBounds();
                if (c && c.busy()) {
                    n = true;
                }
                var m = new Date();
                var o = j.system.renderer;
                if (o !== undefined) {
                    if (o !== e) {
                        o.init(j.system);
                        e = o;
                    }
                    o.redraw({
                        timestamp:m
                    });
                }
                var q = f.last;
                f.last = m;
                f.push(f.last - q);
                if (f.length > 50) {
                    f.shift();
                }
                var p = i.systemEnergy();
                if ((p.mean + p.max) / 2 < 0.05) {
                    if (h === null) {
                        h = new Date().valueOf();
                    }
                    if (new Date().valueOf() - h > 1000) {
                        clearInterval(d);
                        d = null;
                    }
                } else {
                    h = null;
                }
            },
            fps:function (n) {
                if (n !== undefined) {
                    var targetFps = 50;
                    var q = 1000 / Math.max(1, targetFps);
                    j.physicsModified({
                        timeout:q
                    });
                }
                var r = 0;
                for (var p = 0, o = f.length; p < o; p++) {
                    r += f[p];
                }
                var m = r / Math.max(1, f.length);
                if (!isNaN(m)) {
                    return Math.round(1000 / m);
                } else {
                    return 0;
                }
            },
            start:function (m) {
                if (d !== null) {
                    return;
                }
                if (g && !m) {
                    return;
                }
                g = false;
                h = null;
                d = setInterval(j.physicsUpdate, j.system.parameters().timeout);
            },
            stop:function () {
                g = true;
                if (d !== null) {
                    clearInterval(d);
                    d = null;
                }
            }
        };
        return j.init();
    };


    var Node = function (a) {
        this._id = _nextNodeId++;
        this.data = a || {};
        this._mass = (a.mass !== undefined) ? a.mass : 1;
        this._fixed = (a.fixed === true) ? true : false;
        this._p = new Point((typeof (a.x) === "number") ? a.x : null, (typeof (a.y) === "number") ? a.y : null);
        delete this.data.x;
        delete this.data.y;
        delete this.data.mass;
        delete this.data.fixed;
    };

    var _nextNodeId = 1;

    var Edge = function (b, c, a) {
        this._id = _nextEdgeId--;
        this.source = b;
        this.target = c;
        this.length = (a.length !== undefined) ? a.length : 1;
        this.data = (a !== undefined) ? a : {};
        delete this.data.length;
    };

    var _nextEdgeId = -1;

    var Particle = function (a, b) {
        this.p = a;
        this.m = b;
        this.v = new Point(0, 0);
        this.f = new Point(0, 0);
    };

    Particle.prototype.applyForce = function (a) {
        this.f = this.f.add(a.divide(this.m));
    };

    var Spring = function (c, b, d, a) {
        this.point1 = c;
        this.point2 = b;
        this.length = d;
        this.k = a;
    };

    Spring.prototype.distanceToParticle = function (a) {
        var c = this.point2.p.subtract(this.point1.p).normalize().normal();
        var b = a.p.subtract(this.point1.p);
        return Math.abs(b.x * c.x + b.y * c.y);
    };

    var Point = function (a, b) {
        if (a && a.hasOwnProperty("y")) {
            b = a.y;
            a = a.x;
        }
        this.x = a;
        this.y = b;
    };

    Point.prototype = {
		rnd:function (a) {
			a = (a !== undefined) ? a : 5;
			return new Point(2 * a * (Math.random() - 0.5), 2 * a * (Math.random() - 0.5));
		},
        exploded:function () {
            return (isNaN(this.x) || isNaN(this.y));
        },
        add:function (a) {
            return new Point(this.x + a.x, this.y + a.y);
        },
        subtract:function (a) {
            return new Point(this.x - a.x, this.y - a.y);
        },
        multiply:function (a) {
            return new Point(this.x * a, this.y * a);
        },
        divide:function (a) {
            return new Point(this.x / a, this.y / a);
        },
        magnitude:function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        normal:function () {
            return new Point(-this.y, this.x);
        },
        normalize:function () {
            return this.divide(this.magnitude());
        }
    };


    var ParticleSystem = function (d, p, e, f, t, l, q) {
        var j = [];
        var h = null;
        var k = 0;
        var u = null;
        var m = 0.04;
        var i = [20, 20, 20, 20];
        var n = null;
        var o = null;
        if (typeof p === "object") {
            var s = p;
            e = s.friction;
            d = s.repulsion;
            t = s.fps;
            l = s.dt;
            p = s.stiffness;
            f = s.gravity;
            q = s.precision;
        }
        e = isNaN(e) ? 0.5 : e;
        d = isNaN(d) ? 1000 : d;
        t = isNaN(t) ? 55 : t;
        p = isNaN(p) ? 600 : p;
        l = isNaN(l) ? 0.02 : l;
        q = isNaN(q) ? 0.6 : q;
        f = (f === true);
        var r = (t !== undefined) ? 1000 / t : 1000 / 50;
        var b = {
            repulsion:d,
            stiffness:p,
            friction:e,
            dt:l,
            gravity:f,
            precision:q,
            timeout:r
        };
        var a;
        var c = {
            renderer:null,
            nodes:{},
            edges:{},
            adjacency:{},
            names:{},
            kernel:null
        };
        var g = {
            parameters:function (v) {
                if (v !== undefined) {
                    if (!isNaN(v.precision)) {
                        v.precision = Math.max(0, Math.min(1, v.precision));
                    }
                    ext.each(b, function (x) {
                        if (v[x] !== undefined) {
                            b[x] = v[x];
                        }
                    });
                    c.kernel.physicsModified(v);
                }
                return b;
            },
            fps:function (v) {
                if (v === undefined) {
                    return c.kernel.fps();
                } else {
                    g.parameters({
                        timeout:1000 / (v || 50)
                    });
                }
            },
            start:function () {
                c.kernel.start();
            },
            stop:function () {
                c.kernel.stop();
            },
            addNode:function (w, B) {
                B = B || {};
                var C = c.names[w];
                if (C) {
                    C.data = B;
                    return C;
                } else {
                    if (w !== undefined) {
                        var v = (B.x !== undefined) ? B.x : null;
                        var D = (B.y !== undefined) ? B.y : null;
                        var A = (B.fixed) ? 1 : 0;
                        var z = new Node(B);
                        z.name = w;
                        c.names[w] = z;
                        c.nodes[z._id] = z;
                        j.push({
                            t:"addNode",
                            id:z._id,
                            m:z.mass,
                            x:v,
                            y:D,
                            f:A
                        });
                        g._notify();
                        return z;
                    }
                }
            },
            pruneNode:function (w) {
                var v = g.getNode(w);
                if (typeof (c.nodes[v._id]) !== "undefined") {
                    delete c.nodes[v._id];
                    delete c.names[v.name];
                }
                ext.each(c.edges, function (y, x) {
                    if (x.source._id === v._id || x.target._id === v._id) {
                        g.pruneEdge(x);
                    }
                });
                j.push({
                    t:"dropNode",
                    id:v._id
                });
                g._notify();
            },
            getNode:function (v) {
                if (v._id !== undefined) {
                    return v;
                } else {
                    if (typeof v === "string" || typeof v === "number") {
                        return c.names[v];
                    }
                }
            },
            eachNode:function (v) {
                ext.each(c.nodes, function (y, x) {
                    if (x._p.x === null || x._p.y === null) {
                        return;
                    }
                    var w = (u !== null) ? g.toScreen(x._p) : x._p;
                    v.call(g, x, w);
                });
            },
            addEdge:function (z, A, y) {
                z = g.getNode(z) || g.addNode(z);
                A = g.getNode(A) || g.addNode(A);
                y = y || {};
                var x = new Edge(z, A, y);
                var B = z._id;
                var C = A._id;
                c.adjacency[B] = c.adjacency[B] || {};
                c.adjacency[B][C] = c.adjacency[B][C] || [];
                var w = (c.adjacency[B][C].length > 0);
                if (w) {
                    ext.extend(c.adjacency[B][C].data, x.data);
                    return;
                } else {
                    c.edges[x._id] = x;
                    c.adjacency[B][C].push(x);
                    var v = (x.length !== undefined) ? x.length : 1;
                    j.push({
                        t:"addSpring",
                        id:x._id,
                        fm:B,
                        to:C,
                        l:v
                    });
                    g._notify();
                }
                return x;
            },
            pruneEdge:function (A) {
                j.push({
                    t:"dropSpring",
                    id:A._id
                });
                delete c.edges[A._id];
                for (var v in c.adjacency) {
                    for (var B in c.adjacency[v]) {
                        var w = c.adjacency[v][B];
                        for (var z = w.length - 1; z >= 0; z--) {
                            if (c.adjacency[v][B][z]._id === A._id) {
                                c.adjacency[v][B].splice(z, 1);
                            }
                        }
                    }
                }
                g._notify();
            },
            getEdges:function (w, v) {
                w = g.getNode(w);
                v = g.getNode(v);
                if (!w || !v) {
                    return [];
                }
                if (typeof (c.adjacency[w._id]) !== "undefined" && typeof (c.adjacency[w._id][v._id]) !== "undefined") {
                    return c.adjacency[w._id][v._id];
                }
                return [];
            },
            getEdgesFrom:function (v) {
                v = g.getNode(v);
                if (!v) {
                    return [];
                }
                if (typeof (c.adjacency[v._id]) !== "undefined") {
                    var w = [];
                    ext.each(c.adjacency[v._id], function (y, x) {
                        w = w.concat(x);
                    });
                    return w;
                }
                return [];
            },
            getEdgesTo:function (v) {
                v = g.getNode(v);
                if (!v) {
                    return [];
                }
                var w = [];
                ext.each(c.edges, function (y, x) {
                    if (x.target === v) {
                        w.push(x);
                    }
                });
                return w;
            },
            eachEdge:function (v) {
                ext.each(c.edges, function (z, x) {
                    var y = c.nodes[x.source._id]._p;
                    var w = c.nodes[x.target._id]._p;
                    if (y.x === null || w.x === null) {
                        return;
                    }
                    y = (u !== null) ? g.toScreen(y) : y;
                    w = (u !== null) ? g.toScreen(w) : w;
                    if (y && w) {
                        v.call(g, x, y, w);
                    }
                });
            },
            prune:function (w) {
                var v = {
                    dropped:{
                        nodes:[],
                        edges:[]
                    }
                };
                if (w === undefined) {
                    ext.each(c.nodes, function (y, x) {
                        v.dropped.nodes.push(x);
                        g.pruneNode(x);
                    });
                } else {
                    g.eachNode(function (y) {
                        var x = w.call(g, y, {
                            from:g.getEdgesFrom(y),
                            to:g.getEdgesTo(y)
                        });
                        if (x) {
                            v.dropped.nodes.push(y);
                            g.pruneNode(y);
                        }
                    });
                }
                return v;
            },
            graft:function (w) {
                var v = {
                    added:{
                        nodes:[],
                        edges:[]
                    }
                };
                if (w.nodes) {
                    ext.each(w.nodes, function (y, x) {
                        var z = g.getNode(y);
                        if (z) {
                            z.data = x;
                        } else {
                            v.added.nodes.push(g.addNode(y, x));
                        }
                        c.kernel.start();
                    });
                }
                if (w.edges) {
                    ext.each(w.edges, function (z, x) {
                        var y = g.getNode(z);
                        if (!y) {
                            v.added.nodes.push(g.addNode(z, {}));
                        }
                        ext.each(x, function (D, A) {
                            var C = g.getNode(D);
                            if (!C) {
                                v.added.nodes.push(g.addNode(D, {}));
                            }
                            var B = g.getEdges(z, D);
                            if (B.length > 0) {
                                B[0].data = A;
                            } else {
                                v.added.edges.push(g.addEdge(z, D, A));
                            }
                        });
                    });
                }
                return v;
            },
            merge:function (w) {
                var v = {
                    added:{
                        nodes:[],
                        edges:[]
                    },
                    dropped:{
                        nodes:[],
                        edges:[]
                    }
                };
                ext.each(c.edges, function (A, z) {
                    if ((w.edges[z.source.name] === undefined || w.edges[z.source.name][z.target.name] === undefined)) {
                        g.pruneEdge(z);
                        v.dropped.edges.push(z);
                    }
                });
                var y = g.prune(function (A) {
                    if (w.nodes[A.name] === undefined) {
                        v.dropped.nodes.push(A);
                        return true;
                    }
                });
                var x = g.graft(w);
                v.added.nodes = v.added.nodes.concat(x.added.nodes);
                v.added.edges = v.added.edges.concat(x.added.edges);
                v.dropped.nodes = v.dropped.nodes.concat(y.dropped.nodes);
                v.dropped.edges = v.dropped.edges.concat(y.dropped.edges);
                return v;
            },
            _updateGeometry:function (y) {
                if (y !== undefined) {
                    var v = (y.epoch < k);
                    a = y.energy;
                    var z = y.geometry;
                    if (z !== undefined) {
                        for (var x = 0, w = z.length / 3; x < w; x++) {
                            var A = z[3 * x];
                            if (v && c.nodes[A] === undefined) {
                                continue;
                            }
                            c.nodes[A]._p.x = z[3 * x + 1];
                            c.nodes[A]._p.y = z[3 * x + 2];
                        }
                    }
                }
            },
            screenSize:function (v, w) {
                u = {
                    width:v,
                    height:w
                };
                g._updateBounds();
            },
            screenPadding:function (y, z, v, w) {
                var trbl;
                if (ext.isArray(y)) {
                    trbl = y;
                } else {
                    trbl = [y, z, v, w];
                }
                var A = trbl[0];
                var x = trbl[1];
                var B = trbl[2];
                if (x === undefined) {
                    trbl = [A, A, A, A];
                } else {
                    if (B === undefined) {
                        trbl = [A, x, A, x];
                    }
                }
                i = trbl;
            },
            toScreen:function (x) {
                if (!n || !u) {
                    return;
                }
                var w = i || [0, 0, 0, 0];
                var v = n.bottomright.subtract(n.topleft);
                var z = w[3] + x.subtract(n.topleft).divide(v.x).x * (u.width - (w[1] + w[3]));
                var y = w[0] + x.subtract(n.topleft).divide(v.y).y * (u.height - (w[0] + w[2]));
                return new Point(z, y);
            },
            fromScreen:function (z) {
                if (!n || !u) {
                    return;
                }
                var y = i || [0, 0, 0, 0];
                var x = n.bottomright.subtract(n.topleft);
                var w = (z.x - y[3]) / (u.width - (y[1] + y[3])) * x.x + n.topleft.x;
                var v = (z.y - y[0]) / (u.height - (y[0] + y[2])) * x.y + n.topleft.y;
                return new Point(w, v);
            },

            _updateBounds:function (w) {
                if (u === null) {
                    return;
                }
                if (w) {
                    o = w;
                } else {
                    o = g.bounds();
                }
                var z = new Point(o.bottomright.x, o.bottomright.y);
                var y = new Point(o.topleft.x, o.topleft.y);
                var B = z.subtract(y);
                var v = y.add(B.divide(2));
                var x = 4;
                var D = new Point(Math.max(B.x, x), Math.max(B.y, x));
                o.topleft = v.subtract(D.divide(2));
                o.bottomright = v.add(D.divide(2));
                if (!n) {
                    if (ext.isEmptyObject(c.nodes)) {
                        return false;
                    }
                    n = o;
                    return true;
                }
                var C = m;
                var _newBounds = {
                    bottomright:n.bottomright.add(o.bottomright.subtract(n.bottomright).multiply(C)),
                    topleft:n.topleft.add(o.topleft.subtract(n.topleft).multiply(C))
                };
                var A = new Point(n.topleft.subtract(_newBounds.topleft).magnitude(), n.bottomright.subtract(_newBounds.bottomright).magnitude());
                if (A.x * u.width > 1 || A.y * u.height > 1) {
                    n = _newBounds;
                    return true;
                } else {
                    return false;
                }
            },

            energy:function () {
                return a;
            },

            bounds:function () {
                var w = null;
                var v = null;
                ext.each(c.nodes, function (z, y) {
                    if (!w) {
                        w = new Point(y._p);
                        v = new Point(y._p);
                        return;
                    }
                    var x = y._p;
                    if (x.x === null || x.y === null) {
                        return;
                    }
                    if (x.x > w.x) {
                        w.x = x.x;
                    }
                    if (x.y > w.y) {
                        w.y = x.y;
                    }
                    if (x.x < v.x) {
                        v.x = x.x;
                    }
                    if (x.y < v.y) {
                        v.y = x.y;
                    }
                });
                if (w && v) {
                    return {
                        bottomright:w,
                        topleft:v
                    };
                } else {
                    return {
                        topleft:new Point(-1, -1),
                        bottomright:new Point(1, 1)
                    };
                }
            },
            nearest:function (x) {
                if (u !== null) {
                    x = g.fromScreen(x);
                }
                var w = {
                    node:null,
                    point:null,
                    distance:null
                };

                ext.each(c.nodes, function (B, y) {
                    var z = y._p;
                    if (z.x === null || z.y === null) {
                        return;
                    }
                    var A = z.subtract(x).magnitude();
                    if (w.distance === null || A < w.distance) {
                        w = {
                            node:y,
                            point:z,
                            distance:A
                        };
                        if (u !== null) {
                            w.screenPoint = g.toScreen(z);
                        }
                    }
                });
                if (w.node) {
                    if (u !== null) {
                        w.distance = g.toScreen(w.node.p).subtract(g.toScreen(x)).magnitude();
                    }
                    return w;
                } else {
                    return null;
                }
            },
            _notify:function () {
                if (h === null) {
                    k++;
                } else {
                    clearTimeout(h);
                }
                h = setTimeout(g._synchronize, 20);
            },
            _synchronize:function () {
                if (j.length > 0) {
                    c.kernel.graphChanged(j);
                    j = [];
                    h = null;
                }
            }
        };

        c.kernel = Kernel(g);

        Node.prototype.__defineGetter__("p", function () {
            var v = {};
            v.__defineGetter__("x", function () {
                return this._p.x;
            });
            v.__defineSetter__("x", function (x) {
                c.kernel.particleModified(this._id, {
                    x:x
                });
            });
            v.__defineGetter__("y", function () {
                return this._p.y;
            });
            v.__defineSetter__("y", function (x) {
                c.kernel.particleModified(this._id, {
                    y:x
                });
            });
            v.__proto__ = Point.prototype;
            return v;
        });

        Node.prototype.__defineSetter__("p", function (v) {
            this._p.x = v.x;
            this._p.y = v.y;
            c.kernel.particleModified(this._id, {
                x:v.x,
                y:v.y
            });
        });

        Node.prototype.__defineGetter__("mass", function () {
            return this._mass;
        });

        Node.prototype.__defineSetter__("mass", function (v) {
            this._mass = v;
            c.kernel.particleModified(this._id, {
                m:v
            });
        });

        Node.prototype.__defineSetter__("tempMass", function (v) {
            c.kernel.particleModified(this._id, {
                _m:v
            });
        });

        Node.prototype.__defineGetter__("fixed", function () {
            return this._fixed;
        });

        Node.prototype.__defineSetter__("fixed", function (v) {
            this._fixed = v;
            c.kernel.particleModified(this._id, {
                f:v ? 1 : 0
            });
        });
        return g;
    };


    var BarnesHutTree = function () {
        var b = [];
        var a = 0;
        var e = null;
        var d = 0.5;
        var c = {
            init:function (g, h, f) {
                d = f;
                a = 0;
                e = c._newBranch();
                e.origin = g;
                e.size = h.subtract(g);
            },
            insert:function (j) {
                var f = e;
                var g = [j];
                while (g.length) {
                    var h = g.shift();
                    var m = h._m || h.m;
                    var p = c._whichQuad(h, f);
                    if (f[p] === undefined) {
                        f[p] = h;
                        f.mass += m;
                        if (f.p) {
                            f.p = f.p.add(h.p.multiply(m));
                        } else {
                            f.p = h.p.multiply(m);
                        }
                    } else {
                        if ("origin" in f[p]) {
                            f.mass += (m);
                            if (f.p) {
                                f.p = f.p.add(h.p.multiply(m));
                            } else {
                                f.p = h.p.multiply(m);
                            }
                            f = f[p];
                            g.unshift(h);
                        } else {
                            var l = f.size.divide(2);
                            var n = new Point(f.origin);
                            if (p[0] === "s") {
                                n.y += l.y;
                            }
                            if (p[1] === "e") {
                                n.x += l.x;
                            }
                            var o = f[p];
                            f[p] = c._newBranch();
                            f[p].origin = n;
                            f[p].size = l;
                            f.mass = m;
                            f.p = h.p.multiply(m);
                            f = f[p];
                            if (o.p.x === h.p.x && o.p.y === h.p.y) {
                                var k = l.x * 0.08;
                                var i = l.y * 0.08;
                                o.p.x = Math.min(n.x + l.x, Math.max(n.x, o.p.x - k / 2 + Math.random() * k));
                                o.p.y = Math.min(n.y + l.y, Math.max(n.y, o.p.y - i / 2 + Math.random() * i));
                            }
                            g.push(o);
                            g.unshift(h);
                        }
                    }
                }
            },
            applyForces:function (m, g) {
                var f = [e];
                while (f.length) {
                    var node = f.shift();
                    if (node === undefined) {
                        continue;
                    }
                    if (m === node) {
                        continue;
                    }
                    var k;
                    var l;
                    var i;
                    if ("f" in node) {
                        k = m.p.subtract(node.p);
                        l = Math.max(1, k.magnitude());
                        i = ((k.magnitude() > 0) ? k : Point.rnd(1)).normalize();
                        m.applyForce(i.multiply(g * (node._m || node.m)).divide(l * l));
                    } else {
                        var j = m.p.subtract(node.p.divide(node.mass)).magnitude();
                        var h = Math.sqrt(node.size.x * node.size.y);
                        if (h / j > d) {
                            f.push(node.ne);
                            f.push(node.nw);
                            f.push(node.se);
                            f.push(node.sw);
                        } else {
                            k = m.p.subtract(node.p.divide(node.mass));
                            l = Math.max(1, k.magnitude());
                            i = ((k.magnitude() > 0) ? k : Point.rnd(1)).normalize();
                            m.applyForce(i.multiply(g * (node.mass)).divide(l * l));
                        }
                    }
                }
            },
            _whichQuad:function (i, f) {
                if (i.p.exploded()) {
                    return null;
                }
                var h = i.p.subtract(f.origin);
                var g = f.size.divide(2);
                if (h.y < g.y) {
                    if (h.x < g.x) {
                        return "nw";
                    } else {
                        return "ne";
                    }
                } else {
                    if (h.x < g.x) {
                        return "sw";
                    } else {
                        return "se";
                    }
                }
            },
            _newBranch:function () {
                if (b[a]) {
                    var f = b[a];
                    f.ne = f.nw = f.se = f.sw = undefined;
                    f.mass = 0;
                    delete f.p;
                } else {
                    f = {
                        origin:null,
                        size:null,
                        nw:undefined,
                        ne:undefined,
                        sw:undefined,
                        se:undefined,
                        mass:0
                    };
                    b[a] = f;
                }
                a++;
                return f;
            }
        };
        return c;
    };


    var Physics = function (a, m, n, e, h) {
        var f = BarnesHutTree();
        var c = {
            particles:{},
            springs:{}
        };
        var l = {
            particles:{}
        };
        var o = [];
        var k = [];
        var d = 0;
        var b = {
            sum:0,
            max:0,
            mean:0
        };
        var g = {
            topleft:new Point(-1, -1),
            bottomright:new Point(1, 1)
        };
        var j = 1000;
        var i = {
            stiffness:(m !== undefined) ? m : 1000,
            repulsion:(n !== undefined) ? n : 600,
            friction:(e !== undefined) ? e : 0.3,
            gravity:false,
            dt:(a !== undefined) ? a : 0.02,
            theta:0.4,
            init:function () {
                return i;
            },
            modifyPhysics:function (p) {
                ext.each(["stiffness", "repulsion", "friction", "gravity", "dt", "precision"], function (r, s) {
                    if (p[s] !== undefined) {
                        if (s === "precision") {
                            i.theta = 1 - p[s];
                            return;
                        }
                        i[s] = p[s];
                        if (s === "stiffness") {
                            var q = p[s];
                            ext.each(c.springs, function (u, t) {
                                t.k = q;
                            });
                        }
                    }
                });
            },
            addNode:function (u) {
                var t = u.id;
                var q = u.m;
                var p = g.bottomright.x - g.topleft.x;
                var s = g.bottomright.y - g.topleft.y;
                var r = new Point((u.x !== null) ? u.x : g.topleft.x + p * Math.random(), (u.y !== null) ? u.y : g.topleft.y + s * Math.random());
                c.particles[t] = new Particle(r, q);
                c.particles[t].connections = 0;
                c.particles[t].fixed = (u.f === 1);
                l.particles[t] = c.particles[t];
                o.push(c.particles[t]);
            },
            dropNode:function (s) {
                var r = s.id;
                var q = c.particles[r];
                var p = ext.inArray(q, o);
                if (p > -1) {
                    o.splice(p, 1);
                }
                delete c.particles[r];
                delete l.particles[r];
            },
            modifyNode:function (r, p) {
                if (r in c.particles) {
                    var q = c.particles[r];
                    if ("x" in p) {
                        q.p.x = p.x;
                    }
                    if ("y" in p) {
                        q.p.y = p.y;
                    }
                    if ("m" in p) {
                        q.m = p.m;
                    }
                    if ("f" in p) {
                        q.fixed = (p.f === 1);
                    }
                    if ("_m" in p) {
                        if (q._m === undefined) {
                            q._m = q.m;
                        }
                        q.m = p._m;
                    }
                }
            },
            addSpring:function (t) {
                var s = t.id;
                var p = t.l;
                var r = c.particles[t.fm];
                var q = c.particles[t.to];
                if (r !== undefined && q !== undefined) {
                    c.springs[s] = new Spring(r, q, p, i.stiffness);
                    k.push(c.springs[s]);
                    r.connections++;
                    q.connections++;
                    delete l.particles[t.fm];
                    delete l.particles[t.to];
                }
            },
            dropSpring:function (s) {
                var r = s.id;
                var q = c.springs[r];
                q.point1.connections--;
                q.point2.connections--;
                var p = ext.inArray(q, k);
                if (p > -1) {
                    k.splice(p, 1);
                }
                delete c.springs[r];
            },
            _update:function (p) {
                d++;
                ext.each(p, function (q, r) {
                    if (r.t in i) {
                        i[r.t](r);
                    }
                });
                return d;
            },
            tick:function () {
                i.tendParticles();
                i.eulerIntegrator(i.dt);
                i.tock();
            },
            tock:function () {
                var p = [];
                ext.each(c.particles, function (r, q) {
                    p.push(r);
                    p.push(q.p.x);
                    p.push(q.p.y);
                });
                if (h) {
                    h({
                        geometry:p,
                        epoch:d,
                        energy:b,
                        bounds:g
                    });
                }
            },
            tendParticles:function () {
                ext.each(c.particles, function (q, p) {
                    if (p._m !== undefined) {
                        if (Math.abs(p.m - p._m) < 1) {
                            p.m = p._m;
                            delete p._m;
                        } else {
                            p.m *= 0.98;
                        }
                    }
                    p.v.x = p.v.y = 0;
                });
            },
            eulerIntegrator:function (p) {
                if (i.repulsion > 0) {
                    if (i.theta > 0) {
                        i.applyBarnesHutRepulsion();
                    } else {
                        i.applyBruteForceRepulsion();
                    }
                }
                if (i.stiffness > 0) {
                    i.applySprings();
                }
                i.applyCenterDrift();
                if (i.gravity) {
                    i.applyCenterGravity();
                }
                i.updateVelocity(p);
                i.updatePosition(p);
            },
            applyBruteForceRepulsion:function () {
                ext.each(c.particles, function (q, p) {
                    ext.each(c.particles, function (s, r) {
                        if (p !== r) {
                            var u = p.p.subtract(r.p);
                            var v = Math.max(1, u.magnitude());
                            var t = ((u.magnitude() > 0) ? u : Point.rnd(1)).normalize();
                            p.applyForce(t.multiply(i.repulsion * (r._m || r.m) * 0.5).divide(v * v * 0.5));
                            r.applyForce(t.multiply(i.repulsion * (p._m || p.m) * 0.5).divide(v * v * -0.5));
                        }
                    });
                });
            },
            applyBarnesHutRepulsion:function () {
                if (!g.topleft || !g.bottomright) {
                    return;
                }
                var q = new Point(g.bottomright);
                var p = new Point(g.topleft);
                f.init(p, q, i.theta);
                ext.each(c.particles, function (s, r) {
                    f.insert(r);
                });
                ext.each(c.particles, function (s, r) {
                    f.applyForces(r, i.repulsion);
                });
            },
            applySprings:function () {
                ext.each(c.springs, function (t, p) {
                    var s = p.point2.p.subtract(p.point1.p);
                    var q = p.length - s.magnitude();
                    var r = ((s.magnitude() > 0) ? s : Point.rnd(1)).normalize();
                    p.point1.applyForce(r.multiply(p.k * q * -0.5));
                    p.point2.applyForce(r.multiply(p.k * q * 0.5));
                });
            },
            applyCenterDrift:function () {
                var q = 0;
                var r = new Point(0, 0);
                ext.each(c.particles, function (t, s) {
                    r.add(s.p);
                    q++;
                });
                if (q === 0) {
                    return;
                }
                var p = r.divide(-q);
                ext.each(c.particles, function (t, s) {
                    s.applyForce(p);
                });
            },
            applyCenterGravity:function () {
                ext.each(c.particles, function (r, p) {
                    var q = p.p.multiply(-1);
                    p.applyForce(q.multiply(i.repulsion / 100));
                });
            },
            updateVelocity:function (p) {
                ext.each(c.particles, function (t, q) {
                    if (q.fixed) {
                        q.v = new Point(0, 0);
                        q.f = new Point(0, 0);
                        return;
                    }
                    q.v = q.v.add(q.f.multiply(p)).multiply(1 - i.friction);
                    q.f.x = q.f.y = 0;
                    var r = q.v.magnitude();
                    if (r > j) {
                        q.v = q.v.divide(r * r);
                    }
                });
            },
            updatePosition:function (q) {
                var r = 0,
                    p = 0,
                    u = 0;
                var t = null;
                var s = null;
                ext.each(c.particles, function (w, v) {
                    v.p = v.p.add(v.v.multiply(q));
                    var x = v.v.magnitude();
                    var z = x * x;
                    r += z;
                    p = Math.max(z, p);
                    u++;
                    if (!t) {
                        t = new Point(v.p.x, v.p.y);
                        s = new Point(v.p.x, v.p.y);
                        return;
                    }
                    var y = v.p;
                    if (y.x === null || y.y === null) {
                        return;
                    }
                    if (y.x > t.x) {
                        t.x = y.x;
                    }
                    if (y.y > t.y) {
                        t.y = y.y;
                    }
                    if (y.x < s.x) {
                        s.x = y.x;
                    }
                    if (y.y < s.y) {
                        s.y = y.y;
                    }
                });
                b = {
                    sum:r,
                    max:p,
                    mean:r / u,
                    n:u
                };
                g = {
                    topleft:s || new Point(-1, -1),
                    bottomright:t || new Point(1, 1)
                };
            },
            systemEnergy:function () {
                return b;
            }
        };
        return i.init();
    };


    var Parser = function () {
        var strip = function (s) {
            return s.replace(/^[\s\t]+|[\s\t]+$/g, '');
        };

        var recognize = function (s) {
            // return the first {.*} mapping in the string (or "" if none)
            var from = -1,
                to = -1,
                depth = 0;
            ext.each(s, function (i, c) {
                switch (c) {
                    case '{':
                        if (depth === 0 && from === -1) from = i;
                        depth++;
                        break;
                    case '}':
                        depth--;
                        if (depth === 0 && to === -1) to = i + 1;
                        break;
                }
            });
            return s.substring(from, to);
        };

        var unpack = function (os) {
            // process {key1:val1, key2:val2, ...} in a recognized mapping str
            if (!os) return {};

            var pairs = os.substring(1, os.length - 1).split(/\s*,\s*/);
            var kv_data = {};

            ext.each(pairs, function (i, pair) {
                var kv = pair.split(':');
                if (kv[0] === undefined || kv[1] === undefined) return;
                var key = strip(kv[0]);
                var val = strip(kv.slice(1).join(":")); // put back any colons that are part of the value
                if (!isNaN(val)) val = parseFloat(val);
                if (val === 'true' || val === 'false') val = (val === 'true');
                kv_data[key] = val;
            });
            return kv_data;
        };


        var lechs = function (s) {
            var tokens = [];
            var buf = '';

            var flush = function () {
                var bufstr = strip(buf);
                if (bufstr.length > 0) tokens.push({type:"ident", ident:bufstr});
                buf = "";
            };

            s = s.replace(/([ \t]*)?;.*$/, ''); // screen out comments

            for (var i = 0, j = s.length; ;) {
                var c = s[i];
                if (c === undefined) break;
                if (c === '-') {
                    if (s[i + 1] === '>' || s[i + 1] === '-') {
                        flush();
                        var edge = s.substr(i, 2);
                        tokens.push({type:"arrow", directed:(edge === '->')});
                        i += 2;
                    } else {
                        buf += c;
                        i++;
                    }
                } else if (c === '{') {
                    var objStr = recognize(s.substr(i));
                    if (objStr.length === 0) {
                        buf += c;
                        i++;
                    } else {
                        var style = unpack(objStr);
                        if (!ext.isEmptyObject(style)) {
                            flush();
                            tokens.push({type:"style", style:style});
                        }
                        i += objStr.length;
                    }
                } else {
                    buf += c;
                    i++;
                }
                if (i >= j) {
                    flush();
                    break;
                }
            }

            return tokens;
        };

        var yack = function (statements) {
            var nodes = {};
            var edges = {};

            var nodestyle = {};
            var edgestyle = {};
            ext.each(statements, function (i, st) {
                var types = ext.map(st,
                    function (token) {
                        return token.type;
                    }).join('-');

                if (types.match(/ident-arrow-ident(-style)?/)) {
                    // it's an edge
                    var edge = { src:st[0].ident, dst:st[2].ident, style:(st[3] && st[3].style || {}) };
                    edge.style.directed = st[1].directed;
                    if (nodes[edge.src] === undefined) nodes[edge.src] = (ext.isEmptyObject(nodestyle)) ? -2600 : objcopy(nodestyle);
                    if (nodes[edge.dst] === undefined) nodes[edge.dst] = (ext.isEmptyObject(nodestyle)) ? -2600 : objcopy(nodestyle);
                    edges[edge.src] = edges[edge.src] || {};
                    edges[edge.src][edge.dst] = objmerge(edgestyle, edge.style);
                } else if (types.match(/ident-arrow|ident(-style)?/)) {
                    // it's a node declaration (or an edge typo but we can still salvage a node name)
                    var node = st[0].ident;
                    if (st[1] && st[1].style) {
                        nodes[node] = objmerge(nodestyle, st[1].style);
                    } else {
                        nodes[node] = (ext.isEmptyObject(nodestyle)) ? -2600 : objcopy(nodestyle); // use defaults
                    }

                } else if (types === 'style') {
                    // it's a global style declaration for nodes
                    nodestyle = objmerge(nodestyle, st[0].style);
                } else if (types === 'arrow-style') {
                    // it's a global style declaration for edges
                    edgestyle = objmerge(edgestyle, st[1].style);
                }
            });

            // find any nodes that were brought in via an edge then never styled explicitly.
            // they get whatever the final nodestyle was built up to be
            ext.each(nodes, function (name, data) {
                if (data === -2600) {
                    nodes[name] = objcopy(nodestyle);
                }
            });

            return {nodes:nodes, edges:edges};
        };

        var that = {
            lechs:lechs,
            yack:yack,
            parse:function (s) {
                var lines = s.split('\n');
                var statements = [];
                ext.each(lines, function (i, line) {
                    var tokens = lechs(line);
                    if (tokens.length > 0) statements.push(tokens);
                });

                return yack(statements);
            }
        };

        return that;
    };


    var Renderer = function (canvas) {
        var ctx = canvas.getContext("2d");
        var gfx = Graphics(canvas);
        var particleSystem = null;

        var that = {
            init:function (system) {
                particleSystem = system;
                particleSystem.screenSize(canvas.width, canvas.height);
                particleSystem.screenPadding(40);
            },

            redraw:function () {
                if (!particleSystem) return;

                gfx.clear(); // convenience: clears the whole canvas rect

                // draw the nodes & save their bounds for edge drawing
                var nodeBoxes = {};
                particleSystem.eachNode(function (node, pt) {
                    // node: {mass:#, p:{x,y}, name:"", data:{}}
                    // pt:   {x:#, y:#}  node position in screen coords

                    // determine the box size and round off the coords if we'll be
                    // drawing a text label (awful alignment jitter otherwise...)
                    var label = node.data.label || "";
                    var w = ctx.measureText("" + label).width + 10;
                    if (!("" + label).match(/^[ \t]*$/)) {
                        pt.x = Math.floor(pt.x);
                        pt.y = Math.floor(pt.y);
                    } else {
                        label = null;
                    }

                    // draw a rectangle centered at pt
                    if (node.data.color) {
                        ctx.fillStyle = node.data.color;
                    } else {
                        ctx.fillStyle = "rgba(0,0,0,.2)";
                    }
                    if (node.data.color === 'none') ctx.fillStyle = "white";

                    if (node.data.shape === 'dot') {
                        gfx.oval(pt.x - w / 2, pt.y - w / 2, w, w, {fill:ctx.fillStyle});
                        nodeBoxes[node.name] = [pt.x - w / 2, pt.y - w / 2, w, w];
                    } else {
                        gfx.rect(pt.x - w / 2, pt.y - 10, w, 20, 4, {fill:ctx.fillStyle});
                        nodeBoxes[node.name] = [pt.x - w / 2, pt.y - 11, w, 22];
                    }

                    // draw the text
                    if (label) {
                        ctx.font = "12px Helvetica";
                        ctx.textAlign = "center";
                        ctx.fillStyle = "white";
                        if (node.data.color === 'none') ctx.fillStyle = '#333333';
                        ctx.fillText(label || "", pt.x, pt.y + 4);
                        ctx.fillText(label || "", pt.x, pt.y + 4);
                    }
                });


                // draw the edges
                particleSystem.eachEdge(function (edge, pt1, pt2) {
                    // edge: {source:Node, target:Node, length:#, data:{}}
                    // pt1:  {x:#, y:#}  source position in screen coords
                    // pt2:  {x:#, y:#}  target position in screen coords

                    var weight = edge.data.weight;
                    var color = edge.data.color;

                    if (!color || ("" + color).match(/^[ \t]*$/)) color = null;

                    // find the start point
                    var tail = intersect_line_box(pt1, pt2, nodeBoxes[edge.source.name]);
                    var head = intersect_line_box(tail, pt2, nodeBoxes[edge.target.name]);

                    ctx.save();
                    ctx.beginPath();
                    ctx.lineWidth = (!isNaN(weight)) ? parseFloat(weight) : 1;
                    ctx.strokeStyle = (color) ? color : "#cccccc";
                    ctx.moveTo(tail.x, tail.y);
                    ctx.lineTo(head.x, head.y);
                    ctx.stroke();
                    ctx.restore();

                    // draw an arrowhead if this is a -> style edge
                    if (edge.data.directed) {
                        ctx.save();
                        // move to the head position of the edge we just drew
                        var wt = !isNaN(weight) ? parseFloat(weight) : 1;
                        var arrowLength = 6 + wt;
                        var arrowWidth = 2 + wt;
                        ctx.fillStyle = (color) ? color : "#cccccc";
                        ctx.translate(head.x, head.y);
                        ctx.rotate(Math.atan2(head.y - tail.y, head.x - tail.x));

                        // delete some of the edge that's already there (so the point isn't hidden)
                        ctx.clearRect(-arrowLength / 2, -wt / 2, arrowLength / 2, wt);

                        // draw the chevron
                        ctx.beginPath();
                        ctx.moveTo(-arrowLength, arrowWidth);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(-arrowLength, -arrowWidth);
                        ctx.lineTo(-arrowLength * 0.8, -0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                });
            }
        };

        // helpers for figuring out where to draw arrows (thanks springy.js)
        var intersect_line_line = function (p1, p2, p3, p4) {
            var denom = ((p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y));
            if (denom === 0) return false; // lines are parallel
            var ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;
            var ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;

            if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return false;
            return new Point(p1.x + ua * (p2.x - p1.x), p1.y + ua * (p2.y - p1.y));
        };

        var intersect_line_box = function (p1, p2, boxTuple) {
            var p3 = {x:boxTuple[0], y:boxTuple[1]},
                w = boxTuple[2],
                h = boxTuple[3];

            var tl = {x:p3.x, y:p3.y};
            var tr = {x:p3.x + w, y:p3.y};
            var bl = {x:p3.x, y:p3.y + h};
            var br = {x:p3.x + w, y:p3.y + h};

            return intersect_line_line(p1, p2, tl, tr) ||
                intersect_line_line(p1, p2, tr, br) ||
                intersect_line_line(p1, p2, br, bl) ||
                intersect_line_line(p1, p2, bl, tl) ||
                false;
        };

        return that;
    };


    var HalfViz = function () {
        var _canvas = document.getElementById('viewport');
        var sys = ParticleSystem(2600, 512, 0.75);

        var that = {
            init:function () {
                sys.renderer = Renderer(_canvas);
                sys.screenPadding(20);
                that.getDoc();
                return that;
            },

            getDoc:function () {
                var doc_text = ext.loadurl('library/sample1.json');
                var doc = eval('('+doc_text+')');

                if (doc.sys) {
                    sys.parameters(doc.sys);
                }

                var src_txt = doc.src;
                var network = Parser().parse(src_txt);
                ext.each(network.nodes, function (nname, ndata) {
                    if (ndata.label === undefined) ndata.label = nname;
                });
                sys.merge(network);
                that.updateLayout();
            },

            updateLayout:function () {
                var canvW = _canvas.width;
                var canvH = _canvas.height;
                sys.screenSize(canvW, canvH);
                sys.renderer.redraw();
            }
        };

        return that.init();
    };


    HalfViz();

})(this.jQuery);