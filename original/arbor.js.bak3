//
//  Arbor - version 0.91
//  a graph vizualization toolkit
//
//  Copyright (c) 2011 Samizdat Drafting Co.
//  Physics code derived from springy.js, copyright (c) 2010 Dennis Hotson
// 
(function () {

"use strict";

    var ext = {
        each:function (d, e) {
            for (var a in d) {
                e(a, d[a]);
            }
        },

        inArray:function (c, a) {
            for (var d = 0, b = a.length; d < b; d++) {
                if (a[d] === c) {
                    return d;
                }
            }
            return -1;
        }
    };


    var trace = function (msg) {
        console.log(msg);
    };


    var Kernel = function (pSys) {
        var psc = null;
        var itv = null;
        var tm = null;
        var g = false;
        var system = pSys;

        var that = {
            init:function () {
                var m = pSys.parameters();
                psc = Physics(m.dt, m.stiffness, m.repulsion, m.friction, system._updateGeometry);
                that.start();
                return that;
            },

            graphChanged:function (m) {
                psc._update(m);
                that.start();
            },

            particleModified:function (n, m) {
                psc.modifyNode(n, m);
                that.start();
            },

            physicsModified:function (m) {
                if (!isNaN(m.timeout)) {
                    clearInterval(itv);
                    itv = null;
                }
                psc.modifyPhysics(m);
                that.start();
            },

            physicsUpdate:function () {
                psc.tick();
                var n = system._updateBounds();
                var render = system.renderer;
                if (render !== undefined) {
                    render.redraw();
                }
                var p = psc.systemEnergy();
                if ((p.mean + p.max) / 2 < 0.05) {
                    if (tm === null) {
                        tm = new Date().valueOf();
                    }
                    if (new Date().valueOf() - tm > 1000) {
                        clearInterval(itv);
                        itv = null;
                    }
                } else {
                    tm = null;
                }
            },

            start:function (m) {
                if (itv !== null) {
                    return;
                }
                if (g && !m) {
                    return;
                }
                g = false;
                tm = null;
                itv = setInterval(that.physicsUpdate, system.parameters().timeout);
            },

            stop:function () {
                g = true;
                if (itv !== null) {
                    clearInterval(itv);
                    itv = null;
                }
            }
        };
        return that.init();
    };


    var Node = function (a) {
        this._id = _nextNodeId++;
        this.data = a || {};
        this._mass = (a.mass !== undefined) ? a.mass : 1;
        this._fixed = (a.fixed === true) ? true : false;
        this._p = new ArbPoint((typeof (a.x) === "number") ? a.x : null, (typeof (a.y) === "number") ? a.y : null);
        delete this.data.x;
        delete this.data.y;
        delete this.data.mass;
        delete this.data.fixed;
    };

    var _nextNodeId = 1;

    var Edge = function (b, c, a) {
        this._id = _nextEdgeId--;
        this.source = b;
        this.target = c;
        this.length = (a.length !== undefined) ? a.length : 1;
        this.data = (a !== undefined) ? a : {};
        delete this.data.length;
    };

    var _nextEdgeId = -1;

    var Particle = function (a, b) {
        this.p = a;
        this.m = b;
        this.v = new ArbPoint(0, 0);
        this.f = new ArbPoint(0, 0);
    };

    Particle.prototype.applyForce = function (a) {
        this.f = this.f.add(a.divide(this.m));
    };

    var Spring = function (c, b, d, a) {
        this.point1 = c;
        this.point2 = b;
        this.length = d;
        this.k = a;
    };

    var ArbPoint = function (a, b) {
        if (a && a.hasOwnProperty("y")) {
            b = a.y;
            a = a.x;
        }
        this.x = a;
        this.y = b;
    };

    ArbPoint.prototype = {
		rnd:function (a) {
			a = (a !== undefined) ? a : 5;
			return new ArbPoint(2 * a * (Math.random() - 0.5), 2 * a * (Math.random() - 0.5));
		},
        exploded:function () {
            return (isNaN(this.x) || isNaN(this.y));
        },
        add:function (a) {
            return new ArbPoint(this.x + a.x, this.y + a.y);
        },
        subtract:function (a) {
            return new ArbPoint(this.x - a.x, this.y - a.y);
        },
        multiply:function (a) {
            return new ArbPoint(this.x * a, this.y * a);
        },
        divide:function (a) {
            return new ArbPoint(this.x / a, this.y / a);
        },
        magnitude:function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        normal:function () {
            return new ArbPoint(-this.y, this.x);
        },
        normalize:function () {
            return this.divide(this.magnitude());
        }
    };


    var ParticleSystem = function (d, p, e, f, t, l, q) {
        var j = [];
        var h = null;
        var k = 0;
        var u = null;
        var m = 0.04;
        var i = [20, 20, 20, 20];
        var n = null;
        var o = null;

        if (typeof p === "object") {
            var s = p;
            e = s.friction;
            d = s.repulsion;
            t = s.fps;
            l = s.dt;
            p = s.stiffness;
            f = s.gravity;
            q = s.precision;
        }

        e = isNaN(e) ? 0.5 : e;
        d = isNaN(d) ? 1000 : d;
        t = isNaN(t) ? 55 : t;
        p = isNaN(p) ? 600 : p;
        l = isNaN(l) ? 0.02 : l;
        q = isNaN(q) ? 0.6 : q;

        f = (f === true);
        var r = (t !== undefined) ? 1000 / t : 1000 / 50;

        var b = {
            repulsion:d,
            stiffness:p,
            friction:e,
            dt:l,
            gravity:f,
            precision:q,
            timeout:r
        };

        var c_renderer = null;
        var c_nodes = {};
        var c_edges = {};
        var c_adjacency = {};
        var c_names = {};
        var c_kernel = null;

        var that = {
            parameters:function (v) {
                if (v !== undefined) {
                    if (!isNaN(v.precision)) {
                        v.precision = Math.max(0, Math.min(1, v.precision));
                    }
                    ext.each(b, function (x) {
                        if (v[x] !== undefined) {
                            b[x] = v[x];
                        }
                    });
                    c_kernel.physicsModified(v);
                }
                return b;
            },

            start:function () {
                c_kernel.start();
            },

            stop:function () {
                c_kernel.stop();
            },

            addNode:function (w, B) {
                B = B || {};
                var C = c_names[w];
                if (C) {
                    C.data = B;
                    return C;
                } else {
                    if (w !== undefined) {
                        var v = (B.x !== undefined) ? B.x : null;
                        var D = (B.y !== undefined) ? B.y : null;
                        var A = (B.fixed) ? 1 : 0;
                        var z = new Node(B);
                        z.name = w;
                        c_names[w] = z;
                        c_nodes[z._id] = z;
                        j.push({
                            t:"addNode",
                            id:z._id,
                            m:z.mass,
                            x:v,
                            y:D,
                            f:A
                        });
                        that._notify();
                        return z;
                    }
                }
            },

            pruneNode:function (w) {
                var v = that.getNode(w);
                if (typeof (c_nodes[v._id]) !== "undefined") {
                    delete c_nodes[v._id];
                    delete c_names[v.name];
                }
                ext.each(c_edges, function (y, x) {
                    if (x.source._id === v._id || x.target._id === v._id) {
                        that.pruneEdge(x);
                    }
                });
                j.push({
                    t:"dropNode",
                    id:v._id
                });
                that._notify();
            },

            getNode:function (v) {
                if (v._id !== undefined) {
                    return v;
                } else {
                    if (typeof v === "string" || typeof v === "number") {
                        return c_names[v];
                    }
                }
            },

            eachNode:function (v) {
                ext.each(c_nodes, function (y, x) {
                    if (x._p.x === null || x._p.y === null) {
                        return;
                    }
                    var w = (u !== null) ? that.toScreen(x._p) : x._p;
                    v.call(that, x, w);
                });
            },

            addEdge:function (z, A, y) {
                z = that.getNode(z) || that.addNode(z);
                A = that.getNode(A) || that.addNode(A);
                y = y || {};
                var x = new Edge(z, A, y);
                var B = z._id;
                var C = A._id;
                c_adjacency[B] = c_adjacency[B] || {};
                c_adjacency[B][C] = c_adjacency[B][C] || [];
                var w = (c_adjacency[B][C].length > 0);
                if (w) {
                    return;
                } else {
                    c_edges[x._id] = x;
                    c_adjacency[B][C].push(x);
                    var v = (x.length !== undefined) ? x.length : 1;
                    j.push({
                        t:"addSpring",
                        id:x._id,
                        fm:B,
                        to:C,
                        l:v
                    });
                    that._notify();
                }
                return x;
            },

            pruneEdge:function (A) {
                j.push({
                    t:"dropSpring",
                    id:A._id
                });
                delete c_edges[A._id];
                for (var v in c_adjacency) {
                    for (var B in c_adjacency[v]) {
                        var w = c_adjacency[v][B];
                        for (var z = w.length - 1; z >= 0; z--) {
                            if (c_adjacency[v][B][z]._id === A._id) {
                                c_adjacency[v][B].splice(z, 1);
                            }
                        }
                    }
                }
                that._notify();
            },

            getEdges:function (w, v) {
                w = that.getNode(w);
                v = that.getNode(v);
                if (!w || !v) {
                    return [];
                }
                if (typeof (c_adjacency[w._id]) !== "undefined" && typeof (c_adjacency[w._id][v._id]) !== "undefined") {
                    return c_adjacency[w._id][v._id];
                }
                return [];
            },

            getEdgesFrom:function (v) {
                v = that.getNode(v);
                if (!v) {
                    return [];
                }
                if (typeof (c_adjacency[v._id]) !== "undefined") {
                    var w = [];
                    ext.each(c_adjacency[v._id], function (y, x) {
                        w = w.concat(x);
                    });
                    return w;
                }
                return [];
            },

            getEdgesTo:function (v) {
                v = that.getNode(v);
                if (!v) {
                    return [];
                }
                var w = [];
                ext.each(c_edges, function (y, x) {
                    if (x.target === v) {
                        w.push(x);
                    }
                });
                return w;
            },

            eachEdge:function (v) {
                ext.each(c_edges, function (z, x) {
                    var y = c_nodes[x.source._id]._p;
                    var w = c_nodes[x.target._id]._p;
                    if (y.x === null || w.x === null) {
                        return;
                    }
                    y = (u !== null) ? that.toScreen(y) : y;
                    w = (u !== null) ? that.toScreen(w) : w;
                    if (y && w) {
                        v.call(that, x, y, w);
                    }
                });
            },

            prune:function () {
                ext.each(c_nodes, function (y, x) {
                    that.pruneNode(x);
                });
            },

            graft:function (w) {
                var v = {
                    added:{
                        nodes:[],
                        edges:[]
                    }
                };
                if (w.nodes) {
                    ext.each(w.nodes, function (y, x) {
                        var z = that.getNode(y);
                        if (z) {
                            z.data = x;
                        } else {
                            v.added.nodes.push(that.addNode(y, x));
                        }
                        c_kernel.start();
                    });
                }
                if (w.edges) {
                    ext.each(w.edges, function (z, x) {
                        var y = that.getNode(z);
                        if (!y) {
                            v.added.nodes.push(that.addNode(z, {}));
                        }
                        ext.each(x, function (D, A) {
                            var C = that.getNode(D);
                            if (!C) {
                                v.added.nodes.push(that.addNode(D, {}));
                            }
                            var B = that.getEdges(z, D);
                            if (B.length > 0) {
                                B[0].data = A;
                            } else {
                                v.added.edges.push(that.addEdge(z, D, A));
                            }
                        });
                    });
                }
                return v;
            },

            _updateGeometry:function (y) {
                if (y !== undefined) {
                    var v = (y.epoch < k);
                    var z = y.geometry;
                    if (z !== undefined) {
                        for (var x = 0, w = z.length / 3; x < w; x++) {
                            var A = z[3 * x];
                            if (v && c_nodes[A] === undefined) {
                                continue;
                            }
                            c_nodes[A]._p.x = z[3 * x + 1];
                            c_nodes[A]._p.y = z[3 * x + 2];
                        }
                    }
                }
            },

            screenSize:function (v, w) {
                u = {
                    width:v,
                    height:w
                };
                that._updateBounds();
            },

            screenPadding:function (y, z, v, w) {
                var trbl = [y, z, v, w];
                var A = trbl[0];
                var x = trbl[1];
                var B = trbl[2];
                if (x === undefined) {
                    trbl = [A, A, A, A];
                } else {
                    if (B === undefined) {
                        trbl = [A, x, A, x];
                    }
                }
                i = trbl;
            },

            toScreen:function (x) {
                if (!n || !u) {
                    return;
                }
                var w = i || [0, 0, 0, 0];
                var v = n.bottomright.subtract(n.topleft);
                var z = w[3] + x.subtract(n.topleft).divide(v.x).x * (u.width - (w[1] + w[3]));
                var y = w[0] + x.subtract(n.topleft).divide(v.y).y * (u.height - (w[0] + w[2]));
                return new ArbPoint(z, y);
            },

            fromScreen:function (z) {
                if (!n || !u) {
                    return;
                }
                var y = i || [0, 0, 0, 0];
                var x = n.bottomright.subtract(n.topleft);
                var w = (z.x - y[3]) / (u.width - (y[1] + y[3])) * x.x + n.topleft.x;
                var v = (z.y - y[0]) / (u.height - (y[0] + y[2])) * x.y + n.topleft.y;
                return new ArbPoint(w, v);
            },

            _updateBounds:function (w) {
                if (u === null) {
                    return;
                }
                if (w) {
                    o = w;
                } else {
                    o = that.bounds();
                }
                var z = new ArbPoint(o.bottomright.x, o.bottomright.y);
                var y = new ArbPoint(o.topleft.x, o.topleft.y);
                var B = z.subtract(y);
                var v = y.add(B.divide(2));
                var x = 4;
                var D = new ArbPoint(Math.max(B.x, x), Math.max(B.y, x));
                o.topleft = v.subtract(D.divide(2));
                o.bottomright = v.add(D.divide(2));
                if (!n) {
                    n = o;
                    return true;
                }
                var C = m;
                var _newBounds = {
                    bottomright:n.bottomright.add(o.bottomright.subtract(n.bottomright).multiply(C)),
                    topleft:n.topleft.add(o.topleft.subtract(n.topleft).multiply(C))
                };
                var A = new ArbPoint(n.topleft.subtract(_newBounds.topleft).magnitude(), n.bottomright.subtract(_newBounds.bottomright).magnitude());
                if (A.x * u.width > 1 || A.y * u.height > 1) {
                    n = _newBounds;
                    return true;
                } else {
                    return false;
                }
            },

            bounds:function () {
                var w = null;
                var v = null;
                ext.each(c_nodes, function (z, y) {
                    if (!w) {
                        w = new ArbPoint(y._p);
                        v = new ArbPoint(y._p);
                        return;
                    }
                    var x = y._p;
                    if (x.x === null || x.y === null) {
                        return;
                    }
                    if (x.x > w.x) {
                        w.x = x.x;
                    }
                    if (x.y > w.y) {
                        w.y = x.y;
                    }
                    if (x.x < v.x) {
                        v.x = x.x;
                    }
                    if (x.y < v.y) {
                        v.y = x.y;
                    }
                });
                if (w && v) {
                    return {
                        bottomright:w,
                        topleft:v
                    };
                } else {
                    return {
                        topleft:new ArbPoint(-1, -1),
                        bottomright:new ArbPoint(1, 1)
                    };
                }
            },

            _notify:function () {
                if (h === null) {
                    k++;
                } else {
                    clearTimeout(h);
                }
                h = setTimeout(that._synchronize, 20);
            },

            _synchronize:function () {
                if (j.length > 0) {
                    c_kernel.graphChanged(j);
                    j = [];
                    h = null;
                }
            }
        };

        c_kernel = Kernel(that);

        Node.prototype.__defineGetter__("p", function () {
            var v = {};
            v.__defineGetter__("x", function () {
                return this._p.x;
            });
            v.__defineSetter__("x", function (x) {
                c_kernel.particleModified(this._id, {
                    x:x
                });
            });
            v.__defineGetter__("y", function () {
                return this._p.y;
            });
            v.__defineSetter__("y", function (x) {
                c_kernel.particleModified(this._id, {
                    y:x
                });
            });
            v.__proto__ = ArbPoint.prototype;
            return v;
        });

        Node.prototype.__defineSetter__("p", function (v) {
            this._p.x = v.x;
            this._p.y = v.y;
            c_kernel.particleModified(this._id, {
                x:v.x,
                y:v.y
            });
        });

        Node.prototype.__defineGetter__("mass", function () {
            return this._mass;
        });

        Node.prototype.__defineSetter__("mass", function (v) {
            this._mass = v;
            c_kernel.particleModified(this._id, {
                m:v
            });
        });

        Node.prototype.__defineSetter__("tempMass", function (v) {
            c_kernel.particleModified(this._id, {
                _m:v
            });
        });

        Node.prototype.__defineGetter__("fixed", function () {
            return this._fixed;
        });

        Node.prototype.__defineSetter__("fixed", function (v) {
            this._fixed = v;
            c_kernel.particleModified(this._id, {
                f:v ? 1 : 0
            });
        });

        return that;
    };


    var BarnesHutTree = function () {
        var b = [];
        var a = 0;
        var e = null;
        var d = 0.5;

        var that = {
            init:function (g, h, f) {
                d = f;
                a = 0;
                e = that._newBranch();
                e.origin = g;
                e.size = h.subtract(g);
            },

            insert:function (j) {
                var f = e;
                var g = [j];
                while (g.length) {
                    var h = g.shift();
                    var m = h._m || h.m;
                    var p = that._whichQuad(h, f);
                    if (f[p] === undefined) {
                        f[p] = h;
                        f.mass += m;
                        if (f.p) {
                            f.p = f.p.add(h.p.multiply(m));
                        } else {
                            f.p = h.p.multiply(m);
                        }
                    } else {
                        if ("origin" in f[p]) {
                            f.mass += (m);
                            if (f.p) {
                                f.p = f.p.add(h.p.multiply(m));
                            } else {
                                f.p = h.p.multiply(m);
                            }
                            f = f[p];
                            g.unshift(h);
                        } else {
                            var l = f.size.divide(2);
                            var n = new ArbPoint(f.origin);
                            if (p[0] === "s") {
                                n.y += l.y;
                            }
                            if (p[1] === "e") {
                                n.x += l.x;
                            }
                            var o = f[p];
                            f[p] = that._newBranch();
                            f[p].origin = n;
                            f[p].size = l;
                            f.mass = m;
                            f.p = h.p.multiply(m);
                            f = f[p];
                            if (o.p.x === h.p.x && o.p.y === h.p.y) {
                                var k = l.x * 0.08;
                                var i = l.y * 0.08;
                                o.p.x = Math.min(n.x + l.x, Math.max(n.x, o.p.x - k / 2 + Math.random() * k));
                                o.p.y = Math.min(n.y + l.y, Math.max(n.y, o.p.y - i / 2 + Math.random() * i));
                            }
                            g.push(o);
                            g.unshift(h);
                        }
                    }
                }
            },

            applyForces:function (m, g) {
                var f = [e];
                while (f.length) {
                    var node = f.shift();
                    if (node === undefined) {
                        continue;
                    }
                    if (m === node) {
                        continue;
                    }
                    var k;
                    var l;
                    var i;
                    if ("f" in node) {
                        k = m.p.subtract(node.p);
                        l = Math.max(1, k.magnitude());
                        i = ((k.magnitude() > 0) ? k : ArbPoint.rnd(1)).normalize();
                        m.applyForce(i.multiply(g * (node._m || node.m)).divide(l * l));
                    } else {
                        var j = m.p.subtract(node.p.divide(node.mass)).magnitude();
                        var h = Math.sqrt(node.size.x * node.size.y);
                        if (h / j > d) {
                            f.push(node.ne);
                            f.push(node.nw);
                            f.push(node.se);
                            f.push(node.sw);
                        } else {
                            k = m.p.subtract(node.p.divide(node.mass));
                            l = Math.max(1, k.magnitude());
                            i = ((k.magnitude() > 0) ? k : ArbPoint.rnd(1)).normalize();
                            m.applyForce(i.multiply(g * (node.mass)).divide(l * l));
                        }
                    }
                }
            },

            _whichQuad:function (i, f) {
                if (i.p.exploded()) {
                    return null;
                }
                var h = i.p.subtract(f.origin);
                var g = f.size.divide(2);
                if (h.y < g.y) {
                    if (h.x < g.x) {
                        return "nw";
                    } else {
                        return "ne";
                    }
                } else {
                    if (h.x < g.x) {
                        return "sw";
                    } else {
                        return "se";
                    }
                }
            },

            _newBranch:function () {
                if (b[a]) {
                    var f = b[a];
                    f.ne = f.nw = f.se = f.sw = undefined;
                    f.mass = 0;
                    delete f.p;
                } else {
                    f = {
                        origin:null,
                        size:null,
                        nw:undefined,
                        ne:undefined,
                        sw:undefined,
                        se:undefined,
                        mass:0
                    };
                    b[a] = f;
                }
                a++;
                return f;
            }
        };

        return that;
    };


    var Physics = function (a, m, n, e, h) {
        var bht = BarnesHutTree();
        var c_particles = {};
        var c_springs = {};
        var l_particles = {};
        var o = [];
        var k = [];
        var d = 0;

        var b = {
            sum:0,
            max:0,
            mean:0
        };

        var gdt = {
            topleft:new ArbPoint(-1, -1),
            bottomright:new ArbPoint(1, 1)
        };

        var j = 1000;

        var that = {
            stiffness: (m !== undefined) ? m : 1000,
            repulsion: (n !== undefined) ? n : 600,
            friction: (e !== undefined) ? e : 0.3,
            gravity: false,
            dt: (a !== undefined) ? a : 0.02,
            theta: 0.4,

            init:function () {
                return that;
            },

            modifyPhysics:function (p) {
                ext.each(["stiffness", "repulsion", "friction", "gravity", "dt", "precision"], function (r, s) {
                    if (p[s] !== undefined) {
                        if (s === "precision") {
                            that.theta = 1 - p[s];
                            return;
                        }
                        that[s] = p[s];
                        if (s === "stiffness") {
                            var q = p[s];
                            ext.each(c_springs, function (u, t) {
                                t.k = q;
                            });
                        }
                    }
                });
            },

            addNode:function (u) {
                var t = u.id;
                var q = u.m;
                var p = gdt.bottomright.x - gdt.topleft.x;
                var s = gdt.bottomright.y - gdt.topleft.y;
                var r = new ArbPoint((u.x !== null) ? u.x : gdt.topleft.x + p * Math.random(), (u.y !== null) ? u.y : gdt.topleft.y + s * Math.random());
                c_particles[t] = new Particle(r, q);
                c_particles[t].connections = 0;
                c_particles[t].fixed = (u.f === 1);
                l_particles[t] = c_particles[t];
                o.push(c_particles[t]);
            },

            dropNode:function (s) {
                var r = s.id;
                var q = c_particles[r];
                var p = ext.inArray(q, o);
                if (p > -1) {
                    o.splice(p, 1);
                }
                delete c_particles[r];
                delete l_particles[r];
            },

            modifyNode:function (r, p) {
                if (r in c_particles) {
                    var q = c_particles[r];
                    if ("x" in p) {
                        q.p.x = p.x;
                    }
                    if ("y" in p) {
                        q.p.y = p.y;
                    }
                    if ("m" in p) {
                        q.m = p.m;
                    }
                    if ("f" in p) {
                        q.fixed = (p.f === 1);
                    }
                    if ("_m" in p) {
                        if (q._m === undefined) {
                            q._m = q.m;
                        }
                        q.m = p._m;
                    }
                }
            },

            addSpring:function (t) {
                var s = t.id;
                var p = t.l;
                var r = c_particles[t.fm];
                var q = c_particles[t.to];
                if (r !== undefined && q !== undefined) {
                    c_springs[s] = new Spring(r, q, p, that.stiffness);
                    k.push(c_springs[s]);
                    r.connections++;
                    q.connections++;
                    delete l_particles[t.fm];
                    delete l_particles[t.to];
                }
            },

            dropSpring:function (s) {
                var r = s.id;
                var q = c_springs[r];
                q.point1.connections--;
                q.point2.connections--;
                var p = ext.inArray(q, k);
                if (p > -1) {
                    k.splice(p, 1);
                }
                delete c_springs[r];
            },

            _update:function (p) {
                d++;
                ext.each(p, function (q, r) {
                    if (r.t in that) {
                        that[r.t](r);
                    }
                });
                return d;
            },

            tick:function () {
                that.tendParticles();
                that.eulerIntegrator(that.dt);
                that.tock();
            },

            tock:function () {
                var p = [];
                ext.each(c_particles, function (r, q) {
                    p.push(r);
                    p.push(q.p.x);
                    p.push(q.p.y);
                });
                if (h) {
                    h({
                        geometry:p,
                        epoch:d,
                        energy:b,
                        bounds:gdt
                    });
                }
            },

            tendParticles:function () {
                ext.each(c_particles, function (q, p) {
                    if (p._m !== undefined) {
                        if (Math.abs(p.m - p._m) < 1) {
                            p.m = p._m;
                            delete p._m;
                        } else {
                            p.m *= 0.98;
                        }
                    }
                    p.v.x = p.v.y = 0;
                });
            },

            eulerIntegrator:function (p) {
                if (that.repulsion > 0) {
                    if (that.theta > 0) {
                        that.applyBarnesHutRepulsion();
                    } else {
                        that.applyBruteForceRepulsion();
                    }
                }
                if (that.stiffness > 0) {
                    that.applySprings();
                }
                that.applyCenterDrift();
                if (that.gravity) {
                    that.applyCenterGravity();
                }
                that.updateVelocity(p);
                that.updatePosition(p);
            },

            applyBruteForceRepulsion:function () {
                ext.each(c_particles, function (q, p) {
                    ext.each(c_particles, function (s, r) {
                        if (p !== r) {
                            var u = p.p.subtract(r.p);
                            var v = Math.max(1, u.magnitude());
                            var t = ((u.magnitude() > 0) ? u : ArbPoint.rnd(1)).normalize();
                            p.applyForce(t.multiply(that.repulsion * (r._m || r.m) * 0.5).divide(v * v * 0.5));
                            r.applyForce(t.multiply(that.repulsion * (p._m || p.m) * 0.5).divide(v * v * -0.5));
                        }
                    });
                });
            },

            applyBarnesHutRepulsion:function () {
                if (!gdt.topleft || !gdt.bottomright) {
                    return;
                }
                var q = new ArbPoint(gdt.bottomright);
                var p = new ArbPoint(gdt.topleft);
                bht.init(p, q, that.theta);
                ext.each(c_particles, function (s, r) {
                    bht.insert(r);
                });
                ext.each(c_particles, function (s, r) {
                    bht.applyForces(r, that.repulsion);
                });
            },

            applySprings:function () {
                ext.each(c_springs, function (t, p) {
                    var s = p.point2.p.subtract(p.point1.p);
                    var q = p.length - s.magnitude();
                    var r = ((s.magnitude() > 0) ? s : ArbPoint.rnd(1)).normalize();
                    p.point1.applyForce(r.multiply(p.k * q * -0.5));
                    p.point2.applyForce(r.multiply(p.k * q * 0.5));
                });
            },

            applyCenterDrift:function () {
                var q = 0;
                var r = new ArbPoint(0, 0);
                ext.each(c_particles, function (t, s) {
                    r.add(s.p);
                    q++;
                });
                if (q === 0) {
                    return;
                }
                var p = r.divide(-q);
                ext.each(c_particles, function (t, s) {
                    s.applyForce(p);
                });
            },

            applyCenterGravity:function () {
                ext.each(c_particles, function (r, p) {
                    var q = p.p.multiply(-1);
                    p.applyForce(q.multiply(that.repulsion / 100));
                });
            },

            updateVelocity:function (p) {
                ext.each(c_particles, function (t, q) {
                    if (q.fixed) {
                        q.v = new ArbPoint(0, 0);
                        q.f = new ArbPoint(0, 0);
                        return;
                    }
                    q.v = q.v.add(q.f.multiply(p)).multiply(1 - that.friction);
                    q.f.x = q.f.y = 0;
                    var r = q.v.magnitude();
                    if (r > j) {
                        q.v = q.v.divide(r * r);
                    }
                });
            },

            updatePosition:function (q) {
                var r = 0,
                    p = 0,
                    u = 0;
                var t = null;
                var s = null;
                ext.each(c_particles, function (w, v) {
                    v.p = v.p.add(v.v.multiply(q));
                    var x = v.v.magnitude();
                    var z = x * x;
                    r += z;
                    p = Math.max(z, p);
                    u++;
                    if (!t) {
                        t = new ArbPoint(v.p.x, v.p.y);
                        s = new ArbPoint(v.p.x, v.p.y);
                        return;
                    }
                    var y = v.p;
                    if (y.x === null || y.y === null) {
                        return;
                    }
                    if (y.x > t.x) {
                        t.x = y.x;
                    }
                    if (y.y > t.y) {
                        t.y = y.y;
                    }
                    if (y.x < s.x) {
                        s.x = y.x;
                    }
                    if (y.y < s.y) {
                        s.y = y.y;
                    }
                });
                b = {
                    sum:r,
                    max:p,
                    mean:r / u,
                    n:u
                };
                gdt = {
                    topleft:s || new ArbPoint(-1, -1),
                    bottomright:t || new ArbPoint(1, 1)
                };
            },

            systemEnergy:function () {
                return b;
            }
        };
        return that.init();
    };


    var HalfViz = function () {
        var _canvas = document.getElementById('viewport');
        var ctx = _canvas.getContext("2d");
        var sys = ParticleSystem(2600, 512, 0.75);

		var nodes = {};
		var edges = {};

        var that = {
            init:function () {
                sys.renderer = that;
                sys.screenPadding(20);
                that.getDoc();
                return that;
            },

			addEdge: function (src_ident, dst_ident) {
				var edge = { src:src_ident, dst:dst_ident, style:{}};
				edge.style.directed = true;
				if (nodes[edge.src] === undefined) nodes[edge.src] = {};
				if (nodes[edge.dst] === undefined) nodes[edge.dst] = {};
				edges[edge.src] = edges[edge.src] || {};
				edges[edge.src][edge.dst] = edge.style;
			},

			getData: function () {
				that.addEdge("1", "4");
				that.addEdge("1", "12");
				that.addEdge("4", "21");
				that.addEdge("4", "23");
				that.addEdge("7", "34");
				that.addEdge("7", "13");
				that.addEdge("7", "44");
				that.addEdge("12", "25");
				that.addEdge("12", "24");
				that.addEdge("23", "50");
				that.addEdge("23", "53");
				that.addEdge("24", "6");
				that.addEdge("24", "42");
				that.addEdge("25", "94");
				that.addEdge("25", "66");
				that.addEdge("32", "47");
				that.addEdge("32", "84");
				that.addEdge("42", "32");
				that.addEdge("42", "7");
				that.addEdge("50", "72");
				that.addEdge("50", "65");
				that.addEdge("53", "67");
				that.addEdge("53", "68");
				that.addEdge("66", "79");
				that.addEdge("66", "80");
				that.addEdge("67", "88");
				that.addEdge("67", "83");
				that.addEdge("68", "77");
				that.addEdge("68", "91");
				that.addEdge("80", "99");
				that.addEdge("80", "97");
				that.addEdge("88", "110");
				that.addEdge("88", "104");
				that.addEdge("91", "106");
				that.addEdge("91", "100");

				nodes["1"] = {color:"#444", shape:"dot"};
				nodes["4"] = {color:"#2222ff"};
				nodes["6"] = {color:"#c6531e"};
				nodes["7"] = {color:"#2222ff"};
				nodes["13"] = {color:"#c6531e"};
				nodes["12"] = {color:"#c6531e"};
				nodes["21"] = {color:"#c6531e"};
				nodes["34"] = {color:"#db8e3c"};
				nodes["44"] = {color:"#b01700"};
				nodes["47"] = {color:"#ffe35f"};
				nodes["53"] = {color:"#11ff11"};
				nodes["65"] = {color:"#c6531e"};
				nodes["72"] = {color:"#b01700"};
				nodes["77"] = {color:"#b01700"};
				nodes["79"] = {color:"#b01700"};
				nodes["83"] = {color:"#b01700"};
				nodes["84"] = {color:"#b01700"};
				nodes["94"] = {color:"#b01700"};
				nodes["97"] = {color:"#db8e3c"};
				nodes["99"] = {color:"#95cde5"};
				nodes["100"] = {color:"#ffe35f"};
				nodes["104"] = {color:"#c6531e"};
				nodes["106"] = {color:"#ffe35f"};
				nodes["110"] = {color:"#b01700"};

				return {nodes:nodes, edges:edges};
			},

			dsys: {
				repulsion: 10000,
				friction: 0.1,
				stiffness: 1000,
				gravity: true
			},

			getDoc:function () {
                sys.parameters(that.dsys);
				var network = that.getData();
                ext.each(network.nodes, function (nname, ndata) {
                    ndata.label = nname;
                });

                sys.graft(network);
                that.updateLayout();
            },

            updateLayout:function () {
                var canvW = _canvas.width;
                var canvH = _canvas.height;
                sys.screenSize(canvW, canvH);
                sys.renderer.redraw();
            },

            color_encode:function (g) {
                if (!g || typeof g !== "string" || g[0] !== '#') {
                    return "#cccccc";
                }
                return g;
            },

            gfx_clear:function () {
                var s = _canvas.getAttribute("width");
                var t = _canvas.getAttribute("height");
                ctx.clearRect(0, 0, s, t);
            },

            gfx_oval:function (i, n, j, l, k) {
                var m = 0.5522848;
                var ox = (j / 2) * m;
                var oy = (l / 2) * m;
                var xe = i + j;
                var ye = n + l;
                var xm = i + j / 2;
                var ym = n + l / 2;

                ctx.save();
                ctx.beginPath();
                ctx.moveTo(i, ym);
                ctx.bezierCurveTo(i, ym - oy, xm - ox, n, xm, n);
                ctx.bezierCurveTo(xm + ox, n, xe, ym - oy, xe, ym);
                ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                ctx.bezierCurveTo(xm - ox, ye, i, ym + oy, i, ym);
                ctx.closePath();
                if (k.fill !== null) {
                    ctx.fillStyle = that.color_encode(k.fill);
                    ctx.fill();
                }
                if (k.stroke !== null) {
                    ctx.strokeStyle = that.color_encode(k.stroke);
                    if (!isNaN(k.width)) {
                        ctx.lineWidth = k.width;
                    }
                    ctx.stroke();
                }
                ctx.restore();
            },

            gfx_rect:function (j, o, k, m, n, l) {
                var i = (n > 0);
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(j + n, o);
                ctx.lineTo(j + k - n, o);
                if (i) {
                    ctx.quadraticCurveTo(j + k, o, j + k, o + n);
                }
                ctx.lineTo(j + k, o + m - n);
                if (i) {
                    ctx.quadraticCurveTo(j + k, o + m, j + k - n, o + m);
                }
                ctx.lineTo(j + n, o + m);
                if (i) {
                    ctx.quadraticCurveTo(j, o + m, j, o + m - n);
                }
                ctx.lineTo(j, o + n);
                if (i) {
                    ctx.quadraticCurveTo(j, o, j + n, o);
                }
                if (l.fill !== null) {
                    ctx.fillStyle = that.color_encode(l.fill);
                    ctx.fill();
                }
                if (l.stroke !== null) {
                    ctx.strokeStyle = that.color_encode(l.stroke);
                    if (!isNaN(l.width)) {
                        ctx.lineWidth = l.width;
                    }
                    ctx.stroke();
                }
                ctx.restore();
            },

            redraw:function () {
                if (!sys) return;

                that.gfx_clear(); // convenience: clears the whole canvas rect

                // draw the nodes & save their bounds for edge drawing
                var nodeBoxes = {};
                sys.eachNode(function (node, pt) {
                    // node: {mass:#, p:{x,y}, name:"", data:{}}
                    // pt:   {x:#, y:#}  node position in screen coords

                    // determine the box size and round off the coords if we'll be
                    // drawing a text label (awful alignment jitter otherwise...)
                    var label = node.data.label || "";
                    var w = ctx.measureText("" + label).width + 10;
                    if (!("" + label).match(/^[ \t]*$/)) {
                        pt.x = Math.floor(pt.x);
                        pt.y = Math.floor(pt.y);
                    } else {
                        label = null;
                    }

                    // draw a rectangle centered at pt
                    if (node.data.color) {
                        ctx.fillStyle = node.data.color;
                    } else {
                        ctx.fillStyle = "#cccccc";
                    }
                    if (node.data.color === 'none') ctx.fillStyle = "white";

                    if (node.data.shape === 'dot') {
                        that.gfx_oval(pt.x - w / 2, pt.y - w / 2, w, w, {fill:ctx.fillStyle});
                        nodeBoxes[node.name] = [pt.x - w / 2, pt.y - w / 2, w, w];
                    } else {
                        that.gfx_rect(pt.x - w / 2, pt.y - 10, w, 20, 4, {fill:ctx.fillStyle});
                        nodeBoxes[node.name] = [pt.x - w / 2, pt.y - 11, w, 22];
                    }

                    // draw the text
                    if (label) {
                        ctx.font = "12px Helvetica";
                        ctx.textAlign = "center";
                        ctx.fillStyle = "white";
                        if (node.data.color === 'none') ctx.fillStyle = '#333333';
                        ctx.fillText(label || "", pt.x, pt.y + 4);
                        ctx.fillText(label || "", pt.x, pt.y + 4);
                    }
                });

                // draw the edges
                sys.eachEdge(function (edge, pt1, pt2) {
                    // edge: {source:Node, target:Node, length:#, data:{}}
                    // pt1:  {x:#, y:#}  source position in screen coords
                    // pt2:  {x:#, y:#}  target position in screen coords

                    var weight = edge.data.weight;
                    var color = edge.data.color;

                    if (!color || ("" + color).match(/^[ \t]*$/)) color = null;

                    // find the start point
                    var tail = intersect_line_box(pt1, pt2, nodeBoxes[edge.source.name]);
                    var head = intersect_line_box(tail, pt2, nodeBoxes[edge.target.name]);

                    ctx.save();
                    ctx.beginPath();
                    ctx.lineWidth = (!isNaN(weight)) ? parseFloat(weight) : 1;
                    ctx.strokeStyle = (color) ? color : "#cccccc";
                    ctx.moveTo(tail.x, tail.y);
                    ctx.lineTo(head.x, head.y);
                    ctx.stroke();
                    ctx.restore();

                    // draw an arrowhead if this is a -> style edge
                    if (edge.data.directed) {
                        ctx.save();
                        // move to the head position of the edge we just drew
                        var wt = !isNaN(weight) ? parseFloat(weight) : 1;
                        var arrowLength = 6 + wt;
                        var arrowWidth = 2 + wt;
                        ctx.fillStyle = (color) ? color : "#cccccc";
                        ctx.translate(head.x, head.y);
                        ctx.rotate(Math.atan2(head.y - tail.y, head.x - tail.x));

                        // delete some of the edge that's already there (so the point isn't hidden)
                        ctx.clearRect(-arrowLength / 2, -wt / 2, arrowLength / 2, wt);

                        // draw the chevron
                        ctx.beginPath();
                        ctx.moveTo(-arrowLength, arrowWidth);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(-arrowLength, -arrowWidth);
                        ctx.lineTo(-arrowLength * 0.8, -0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                });
            }
		};

        var intersect_line_line = function (p1, p2, p3, p4) {
            var denom = ((p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y));
            if (denom === 0) return false; // lines are parallel
            var ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;
            var ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;

            if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return false;
            return new ArbPoint(p1.x + ua * (p2.x - p1.x), p1.y + ua * (p2.y - p1.y));
        };

        var intersect_line_box = function (p1, p2, boxTuple) {
            var p3 = {x:boxTuple[0], y:boxTuple[1]},
                w = boxTuple[2],
                h = boxTuple[3];

            var tl = {x:p3.x, y:p3.y};
            var tr = {x:p3.x + w, y:p3.y};
            var bl = {x:p3.x, y:p3.y + h};
            var br = {x:p3.x + w, y:p3.y + h};

            return intersect_line_line(p1, p2, tl, tr) ||
                intersect_line_line(p1, p2, tr, br) ||
                intersect_line_line(p1, p2, br, bl) ||
                intersect_line_line(p1, p2, bl, tl) ||
                false;
        };

        return that.init();
    };


    HalfViz();

})();